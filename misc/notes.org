
* Actions and Ideas
** COMMENT Stuff that is parked

# Blend the refractive indices of three orientations of a material and
# write the result to =particle-blend.lnk=, usng the wavelength grid
# given in o1.lnk.
#
# : optool -blendonly -c o1.lnk .33 -c o2.lnk .33 -c o3.lnk .33 -l o1.lnk

# - particle-blend.lnk ::
#
#  When =optool= is called with the =-blendonly= switch, the resulting
#  optical properties of the full mix including mantle and porosity are
#  written to this =lnk= file.

# + =-mmf [D_FRACTAL [A_MONO]]=
#
#  Use Modified Mean Field theory (Tazaki & Tanaka 2008) to correct
#  absorption and scattering cross sections for very porous
#  aggregates.  The optional parameters are the fractal dimension and
#  the monomer size, with default values of 3.0 and 0.1 [micron],
#  respectively.


# + =-lunit UNIT= ::
#
#  =optool= uses *microns* as the unit for wavelengths and grain sizes,
#  in line with Michiel Min's original conventions.  With this switch,
#  use =-lunit cm= or =-lunit m= to assume for wavelengths and grain
#  sizes on the command line, in =lnk= files read by the program and
#  output files produced. Note that cross sections are always cm^2/g.

#
# + =-b, -blendonly= :: 
#
#  Only blend the material properties and write the result to a new
#  =lnk= file, =particle_blend.lnk=.

# + =-B= ::
# 
#   Use the old style Blender, for robustness
** TODO Fixed to RADMC-3D output
- The scattering matrix has to be given on interfaces, not on cell centers
  - So we interpolate two values to get 179 values
  - The we duplicate the first and last values and write that to a file.
- We need a -chop DEGREE switch, that will chop off N degrees of the
  scattering (set F11 constant there) and then recompute kappascat by integration.
- The value of the chopping angle needs to go into the header.
** DONE multicore

I did some tests on my 4 coures Macbook Pro, and on my 2 core Macbook
pro.

        4-core machine   2-core machine
|    N | User4 | Real4 | User2 | real2 |
|------+-------+-------+-------+-------|
|    1 |  1:19 |  1:19 |  1:44 |  2:05 |
|    2 |  1:19 |  1:16 |  1:37 |  1:43 |
|    4 |  1:21 |  0:49 |  1:51 |  1:12 |
|    8 |  1:33 |  0:25 |  2:20 |  0:51 |
|   16 |  2:10 |  0:22 |  2:23 |  0:48 |
|   30 |  2:22 |  0:21 |  2:26 |  0:21 |
| free |       |       |  1:48 |  1:09 |



Now I have two parallel plans.  Split runs, where we produce many
files, makes the runs for each file parallel.  If we produce only a
single file, then the wavelength loop is parallel.  In both cases we
get a factor 6 or so, so this is pretty cool.

|        | broad | split |
| single |  2:48 | 13:11 |
| multi  |  0:23 |  2:09 |
|        |       |       |
|--------+-------+-------|
|        |   168 |   791 |
|        |    23 |   129 |
|        |  7.30 |  6.13 |
|        |       |       |
#+TBLFM: @6$2=23::@6$3=129::@7$2=168/23;%.2f::@7$3=791/129;%.2f
*** Testing results

Everything seems to be OK with the -d switch.

However, without it, when lambda is run in parallel, the resulds to
differ, so apparently there is a problem there.  I need to go through
it and check.

** TODO Mean opacities including Tstar and evaporation

-c material mfrac tevap

Then some internal magic

Need to specify a dust to gas ratio, because these should be per g
gas.  or per gicy region? or....?????

** TODO propagate rho to fits and write it there?
** DONE Does the angular grid have to be configurable?
Michiels code does assum that teh grid is regular in two places.
1. DMieLay only computes from 0 to pi/2, and then the other half is
   constructed from what we already have
2. Michiel adjusts the forward peak (gust that one grid point) to
   ensure F11 is OK normalised.  The integration done for this assumes
   that the grid is regular (dphi is dropped out of the equation.

So, if we want to refine the grid, we have to do it both at phi=0 and
at phi=pi.  Or, we make a computation with increasing the total number
of grid points, and then let the user program do the interpolation.

Or, if the user asks us to refine at forward, we can just internally
increase nang sufficiently and then interpolate on the grid the user
wants.  Lots of possibilities, all a but complicated.

Another issue is that the 180 is hard-coded in some array dimensions.
So this would have to be fixed as well.  A consequence qould be the
the fits files no longer have fixed array sizes, the the readers of
those files would have to adapt.

For now, I think we leave the angular grid alone - until the need
arizes to change it.

** TODO Fix the FITS issues
Python cannot read the headers.  I should check if Fortran actually can!?
** TODO Add an amorphous water ice
** TODO Add more materials
what would be useful?
- the T-dependant Forsterite stuff?
  - Files are large, hey start only at 5um, I would have to mix the
    three directions...
- A few ices, maybe.
  
Only ones with good wavelength coverage.
What does Christian Lammert use?
** TODO Make a comparison between the two blenders
* Strategy
** Read lnk data for all materials
** Do the mixing, so that we end up with a single material
** Loop over all lambda
- Loop over particle sizes
  - Loop over the DHS volumes
    - Call DMiLay, get back qext,qsca,qabs,gqsc,m1,m2,s21,d21
      From those, we construct the Mief's.  The larger angles come
      from the smaller ones, with some kind of symmetry
    - If the sphere is too large (2 pi a/lambda > 1e4, or if there is an error in DMiLay
      - Call MeerhoffMie instead.
      - However, if the grain is too large too large, fix the wavelength to be grain
        radius/5000, and then call Meerhoffmie
      - That gives all the Mief's directly, take it from there.
    - Renormalize Mief11, just the 0 degrees value
    - add wighted contribution to the matrix
    - add weighted contribution to the cappas cext_ff etc
  - Add contributions to the cappas cext
  - Set the kappas and the finla scattering matrix for thet wavelength
